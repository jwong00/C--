package wci.backend.compiler;

import java.util.ArrayList;
import java.util.HashMap;
import java.io.*;

import wci.frontend.*;
import wci.intermediate.*;
import wci.intermediate.symtabimpl.Predefined;
import wci.backend.*;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.symtabimpl.DefinitionImpl.*;
import static wci.intermediate.icodeimpl.ICodeKeyImpl.*;

/**
 * <p>The code generator for a compiler back end.</p>
 *
 * <p>Copyright (c) 2008 by Ronald Mak</p>
 * <p>For instructional purposes only.  No warranties.</p>
 */
public class CodeGenerator extends Backend
{
    private static final int STACK_LIMIT = 16;
        
    static ICode iCode;
    static SymTabStack symTabStack;
    static PrintWriter objectFile;

    public static HashMap<String, String> typeSpecToJasmin;

    static {
        typeSpecToJasmin = new HashMap<>();
        typeSpecToJasmin.put(Predefined.integerType.getIdentifier().getName(), "I");
        typeSpecToJasmin.put(Predefined.floatType.getIdentifier().getName(), "F");
        typeSpecToJasmin.put(Predefined.charType.getIdentifier().getName(), "Ljava/lang/String;");
    }

    /**
     * Process the intermediate code and the symbol table generated by the
     * parser to generate machine-language instructions.
     * @param iCode the intermediate code.
     * @param symTabStack the symbol table stack.
     * @param objectFile the object file path for the generated code.
     * @throws Exception if an error occurred.
     */
    public void process(ICode iCode, SymTabStack symTabStack,
                        String objectFilePath)
        throws Exception
    {
        CodeGenerator.iCode       = iCode;
        CodeGenerator.symTabStack = symTabStack;
        CodeGenerator.objectFile  = new PrintWriter(objectFilePath);

        // Make the program and method names.
        String programName = generateProgramName(objectFilePath);
        String methodName = programName.substring(0, 1).toLowerCase() +
                            programName.substring(1);
        
        SymTabEntry programId = symTabStack.getProgramId();
        Integer localsCount = 
                (Integer) programId.getAttribute(ROUTINE_LOCALS_COUNT);

        if(localsCount == null || localsCount == 0) {
            localsCount = 1;
        }

        SymTab routineSymTab = 
                (SymTab) programId.getAttribute(ROUTINE_SYMTAB);
        ArrayList<SymTabEntry> locals = routineSymTab.sortedEntries();

        // Generate the program header.
        objectFile.println(".class public " + programName);
        objectFile.println(".super java/lang/Object");
        objectFile.println();
        
        // Generate code for fields.
        for (SymTabEntry id : locals) {
            Definition defn = id.getDefinition();
            
            if (defn == VARIABLE) {
                String fieldName = id.getName();
                TypeSpec type = id.getTypeSpec();
                String typeCode = null;

                if(type == Predefined.integerType) {
                    typeCode = "I";
                } else if ( type == Predefined.floatType ) {
                    typeCode = "F";
                } else {
                    typeCode = "Ljava/lang/String;";
                } 

                objectFile.println(".field private static " + fieldName + 
                		           " " + typeCode);
            }
        }
        objectFile.println();
        
        // Generate the class constructor.
        objectFile.println(".method public <init>()V");
        objectFile.println();
        objectFile.println("	aload_0");
        objectFile.println("	invokenonvirtual	java/lang/Object/<init>()V");
        objectFile.println("	return");
        objectFile.println();
        objectFile.println(".limit locals " + localsCount);
        objectFile.println(".limit stack 1");
        objectFile.println(".end method");
        objectFile.println();

        CodeGeneratorVisitor codeVisitor = new CodeGeneratorVisitor(symTabStack);
        Node rootNode = iCode.getRoot();

        // emit the code for any user-defined functions
        int numChildren = rootNode.jjtGetNumChildren();

        // emit the code for every child except the last, which should be main
        for (int i = 0; i < numChildren-1; i++) {
            SimpleNode n = (SimpleNode) rootNode.jjtGetChild(i);
            emitFunction(n, codeVisitor, programName);
        }

        Node mainNode = rootNode.jjtGetChild(numChildren-1);
        
        // Generate the main method header.
        objectFile.println(".method public static main([Ljava/lang/String;)V");
        objectFile.println();
        objectFile.flush();

        // Visit the parse tree nodes to generate code 
        // for the main method's compound statement.
        mainNode.jjtAccept(codeVisitor, programName);
        objectFile.println();

        // Generate the main method epilogue.
        objectFile.println("    return");
        objectFile.println();
        objectFile.println(".limit locals " + localsCount);
        objectFile.println(".limit stack  " + STACK_LIMIT);
        objectFile.println(".end method");
        objectFile.flush();

        CodeGenerator.objectFile.close();
    }

    private static void emitFunction(SimpleNode fnDefNode, CodeGeneratorVisitor visitor, String programName) {
        // first child should be the variable type
        SimpleNode typeNode = (SimpleNode) fnDefNode.jjtGetChild(0);
        TypeSpec returnType = typeNode.getTypeSpec();
        String returnTypeStr = typeSpecToJasmin.get(returnType.getIdentifier().getName());

        // void type
        if (returnTypeStr == null) {
            returnTypeStr = "V";
        }

        // second child should be the function identifier
        SimpleNode identNode = (SimpleNode) fnDefNode.jjtGetChild(1);
        String fnName = (String) identNode.jjtGetValue();

        SimpleNode paramsNode = null;
        SimpleNode compoundStatementNode = null;

        switch(fnDefNode.jjtGetNumChildren()) {
            case 3:
                // no parameters, so the last one is the compound statement
                compoundStatementNode = (SimpleNode) fnDefNode.jjtGetChild(2);
                break;
            case 4:
                // third should be the parameters
                paramsNode = (SimpleNode) fnDefNode.jjtGetChild(2);

                // and last, but not least, the actual code
                compoundStatementNode = (SimpleNode) fnDefNode.jjtGetChild(3);

                break;
        }

        String paramCodes = generateParamCodeList(paramsNode);
        SymTabEntry funcId = (SymTabEntry) fnDefNode.getAttribute(ID);
        Integer localsCount = null;

        if(funcId != null) {
            localsCount = (Integer) funcId.getAttribute(ROUTINE_LOCALS_COUNT);
        }

        if (localsCount == null || localsCount == 0) {
            localsCount = 1;
        }

        // declare the method in Jasmin
        String jMethodDecl =
            String.format(".method public static %s(%s)%s",
                fnName, paramCodes, returnTypeStr
            );

        objectFile.println(jMethodDecl);
        objectFile.println();

        // emit the code
        compoundStatementNode.jjtAccept(visitor, programName);

        // end the method def
        if(returnTypeStr.equals("V")) {
            objectFile.println("    return");
        } else if (returnTypeStr.equals("Ljava/lang/String;")) {
            objectFile.println("    areturn");
        } else {
            objectFile.println(String.format("    %sreturn", returnTypeStr.toLowerCase()));
        }

        objectFile.println();
        objectFile.println(".limit locals " + localsCount);
        objectFile.println(".limit stack  " + STACK_LIMIT);
        objectFile.println(".end method");
        objectFile.println();
        objectFile.flush();
    }

    private static String generateParamCodeList(SimpleNode paramsNode) {
        if(paramsNode == null) {
            return "";
        }

        StringBuilder paramCodeList = new StringBuilder();

        int numChildren = paramsNode.jjtGetNumChildren();

        for (int i = 0; i < numChildren; i++) {
            SimpleNode varDeclExprNode = (SimpleNode) paramsNode.jjtGetChild(i);
            SimpleNode varTypeNode = (SimpleNode) varDeclExprNode.jjtGetChild(0);
            TypeSpec type = varTypeNode.getTypeSpec();
            String typeCode = typeSpecToJasmin.get(type.getIdentifier().getName());
            paramCodeList.append(typeCode);
        }

        return paramCodeList.toString();
    }

    public static String generateProgramName(String objectFilePath) {
		String sep = System.getProperty("file.separator");
        int start = objectFilePath.lastIndexOf(sep) + 1;
        String programName = objectFilePath.substring(start);
        int end = programName.indexOf(".");
        if (end > -1) {
            programName = programName.substring(0, end);
        }
        programName = programName.substring(0, 1).toUpperCase() +
                      programName.substring(1);

        return programName;
    }
}
